import ast
from datetime import datetime, time, timedelta

import pandas as pd
import plotly.express as px
import streamlit as st


@st.cache_data(show_spinner=False)
def load_data(csv_path: str) -> pd.DataFrame:
    """Load the preâ€‘extracted Cynosure events data from a CSV.

    The CSV file is generated by a Python script that scraped the
    Cynosure brochure and duty list. It contains columns such as
    Event, Teacher, Duty Date, Duty Age, Date, Participants,
    Time, Age Category, Duration, Event Category, Venue and
    Dress Code. Teachers are stored as stringified Python lists.

    Args:
        csv_path: Path to the CSV file relative to the project root.

    Returns:
        A DataFrame with the Teacher column converted back into a list.
    """
    df = pd.read_csv(csv_path)
    # Convert the string representation of lists back into Python lists
    df['Teacher'] = df['Teacher'].apply(
        lambda x: ast.literal_eval(x) if isinstance(x, str) and x.startswith('[') else []
    )
    return df


def parse_time_range(time_str: str) -> tuple[time, time]:
    """Parse a time range like '10:30 a.m. to 1:30 p.m.' into start and end time objects.

    The brochure lists times in the format 'HH:MM a.m./p.m. to HH:MM a.m./p.m.'
    or similar. This function converts such strings into Python time objects.
    If the time string is missing or malformed, returns (None, None).

    Args:
        time_str: A string representing the time range.

    Returns:
        A tuple (start_time, end_time) of Python time objects or (None, None).
    """
    if not isinstance(time_str, str) or 'to' not in time_str:
        return None, None
    try:
        start_part, end_part = [p.strip() for p in time_str.lower().split('to')]
        # Normalize periods
        def parse_part(part: str) -> time:
            # Replace spaces and remove trailing punctuation
            part = part.replace('.', '').replace('a m', 'am').replace('p m', 'pm')
            part = part.replace('a.m.', 'am').replace('p.m.', 'pm').replace('a.m', 'am').replace('p.m', 'pm')
            # Remove any extra spaces
            part = part.replace('  ', ' ')
            return datetime.strptime(part, '%I:%M %p').time()

        start_time = parse_part(start_part)
        end_time = parse_part(end_part)
        return start_time, end_time
    except Exception:
        return None, None


def parse_duty_dates(date_str: str) -> list[datetime]:
    """Parse duty date strings into a list of datetime objects.

    Duty dates in the duty list can appear in formats like '26/09/2025',
    '27/09/2025', or combined with ampersands, e.g., '26/09/2025 & 27/09/2025'.
    This helper returns a list of datetime objects with time set to midnight.

    Args:
        date_str: A string representing one or more dates.

    Returns:
        A list of datetime objects for each parsed date. Invalid parts are skipped.
    """
    dates = []
    if not isinstance(date_str, str) or not date_str.strip():
        return dates
    for part in date_str.replace(' ', '').split('&'):
        # Some dates may include hyphen separators or text after the date.
        part = part.strip()
        # Extract only the day/month/year pattern using slicing
        # for example '26/09/2025-Friday' -> '26/09/2025'
        for token in part.split('-'):
            if '/' in token:
                try:
                    dt = datetime.strptime(token, '%d/%m/%Y')
                    dates.append(dt)
                    break
                except Exception:
                    continue
    return dates


def build_timeline(df: pd.DataFrame) -> pd.DataFrame:
    """Construct a timeline DataFrame suitable for a Gantt chart.

    This function expands each event row for every duty date found in
    the 'Duty Date' column. It then parses the 'Time' field to obtain
    start and end times. If times are missing, they default to the
    full day (8:00 a.m. to 5:30 p.m.). The resulting DataFrame has
    columns required by Plotly's timeline chart: 'Event', 'Start', and
    'Finish'.

    Args:
        df: The events DataFrame.

    Returns:
        An expanded DataFrame with columns Event, Start, Finish.
    """
    rows = []
    for _, row in df.iterrows():
        duty_date_str = row.get('Duty Date')
        if not isinstance(duty_date_str, str):
            continue
        dates = parse_duty_dates(duty_date_str)
        if not dates:
            continue
        # Parse the time range for the event. Use a default full day if unavailable.
        start_time, end_time = parse_time_range(row.get('Time', ''))
        if start_time is None or end_time is None:
            start_time = time(8, 0)  # default start at 8:00 a.m.
            end_time = time(17, 30)  # default end at 5:30 p.m.
        for date_obj in dates:
            start_dt = datetime.combine(date_obj.date(), start_time)
            # If end time is earlier than start time (rare due to noon crossing), add one day
            finish_dt = datetime.combine(date_obj.date(), end_time)
            if finish_dt <= start_dt:
                finish_dt += timedelta(days=1)
            rows.append({
                'Event': row['Event'],
                'Start': start_dt,
                'Finish': finish_dt,
            })
    return pd.DataFrame(rows)


def main() -> None:
    st.set_page_config(page_title="Cynosure 2025 Duty List Explorer", layout="wide")
    st.title("Cynosure 2025 Duty List Explorer")
    st.markdown(
        """
        Use this interactive tool to search for events by teacher and explore the
        schedule for the Cynosure 2025 festival. The dataset combines information
        from the official brochure and the duty list, capturing details like
        participants, venue and dress code. Enter a teacher's name in the
        search box below to view their assigned events. The timeline section
        visualises when each event takes place across the festival days.
        """
    )

    # Load data
    data = load_data('cynosure_events_data.csv')

    # Teacher search
    st.sidebar.header("Search by Teacher")
    teacher_input = st.sidebar.text_input(
        "Enter teacher's name",
        help="Type any part of a teacher's name to find their events."
    )
    teacher_input_lower = teacher_input.lower().strip() if teacher_input else ''

    if teacher_input_lower:
        # Filter rows where any teacher contains the search string
        mask = data['Teacher'].apply(
            lambda teachers: any(teacher_input_lower in t.lower() for t in teachers)
        )
        results = data[mask]
        if results.empty:
            st.warning("No events found for this teacher. Please check the spelling or try a partial match.")
        else:
            st.subheader(f"Events for '{teacher_input}':")
            for _, event_row in results.iterrows():
                st.markdown(f"### {event_row['Event']}")
                # Display each attribute wordâ€‘forâ€‘word as in the brochure/duty list
                for field in [
                    'Teacher', 'Duty Date', 'Duty Age', 'Date', 'Participants',
                    'Time', 'Age Category', 'Duration', 'Event Category',
                    'Venue', 'Dress Code'
                ]:
                    value = event_row.get(field)
                    # Convert lists to commaâ€‘separated strings
                    if isinstance(value, list):
                        value = ', '.join(value)
                    value = value if pd.notnull(value) else 'N/A'
                    st.write(f"**{field}:** {value}")
                st.markdown("---")

    # Timeline Section
    st.header("Event Timeline")
    timeline_df = build_timeline(data)
    if timeline_df.empty:
        st.info("Timeline data could not be generated due to missing dates.")
    else:
        # Sort timeline by start time
        timeline_df = timeline_df.sort_values(by='Start')
        fig = px.timeline(
            timeline_df,
            x_start="Start",
            x_end="Finish",
            y="Event",
            color="Event",
            title="Cynosure 2025 Event Timeline",
        )
        fig.update_layout(
            xaxis_title="Date and Time",
            yaxis_title="Events",
            showlegend=False,
            margin=dict(l=20, r=20, t=60, b=20)
        )
        # Show the timeline
        st.plotly_chart(fig, use_container_width=True)


if __name__ == '__main__':

    main()
